(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{146:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return d}));var r=n(1),i=n(10),o=(n(0),n(161)),a={title:"Promises & Async",description:"All things related to Promises and asynchronous programming",last_modified:new Date("2021-10-11T00:00:00.000Z"),sidebar_label:"Promises & Async"},s={id:"javascript/promises",title:"Promises & Async",description:"All things related to Promises and asynchronous programming",source:"@site/docs/javascript/promises.md",permalink:"/learning-notes/javascript/promises",sidebar_label:"Promises & Async",sidebar:"docs",previous:{title:"Background jobs",permalink:"/learning-notes/backend/background-jobs"}},l=[{value:"Single or multi-threaded?",id:"single-or-multi-threaded",children:[]},{value:"Defer pattern (or antipattern?)",id:"defer-pattern-or-antipattern",children:[]}],c={rightToc:l};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"All things related to Promises and asynchronous programming")),Object(o.b)("h2",{id:"single-or-multi-threaded"},"Single or multi-threaded?"),Object(o.b)("p",null,"The main Javascript execution context is single-threaded, NOT multithreaded. The underlying engine however can be (and I think IS) multithreaded."),Object(o.b)("p",null,"The event loop merely gives the illusion of things happening in parallel, however at any point in time only a single piece of code runs. "),Object(o.b)("p",null,"If we take the example of an async with say 3 ",Object(o.b)("inlineCode",{parentName:"p"},"await"),' points, we can roughly think of that function\'s code as being broken down to 4 "contiguous pieces of synchronous code", which we can call Tasks.'),Object(o.b)("p",null,'Each task runs in one go until completion. When we hit an await, the function takes a "break" and the engine chooses another task to run. '),Object(o.b)("p",null,"So it is akin to having multiple processes running on a single core, and the OS schedule execution. However, what is important to remember, is that Javascript tasks run until completion, while the OS runs until pre-emption."),Object(o.b)("h2",{id:"defer-pattern-or-antipattern"},"Defer pattern (or antipattern?)"),Object(o.b)("p",null,'It is possible to create a Promise that can be resolved "externally" and "manually" - that is, from outside the ',Object(o.b)("inlineCode",{parentName:"p"},"(resolve, reject) => {...}")," callback."),Object(o.b)("p",null,"It looks like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-javascript"}),"// https://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/\n\nmodule.exports = function defer() {\n    let res\n    let rej\n\n    const promise = new Promise((resolve, reject) => {\n        res = resolve\n        rej = reject\n    })\n\n    promise.resolve = res\n    promise.reject = rej\n\n    return promise\n}\n")),Object(o.b)("p",null,"This is called a Deferred pattern and is actually discouraged from use when using Promises, however there might a time it is needed so it is good to know."),Object(o.b)("div",{class:"github-footer"},Object(o.b)("p",null,Object(o.b)("svg",{class:"embedded-fa-icon"},Object(o.b)("use",{href:"#github"}))," ",Object(o.b)("strong",null,Object(o.b)("a",{href:"https://github.com/MehdiSaffar/learning-notes/blob/master/javascript/promises.md",target:"_blank",rel:"nofollow noopener noreferrer"},"View this note on GitHub ",Object(o.b)("svg",{class:"embedded-fa-icon"},Object(o.b)("use",{href:"#external-link-alt"}))))),Object(o.b)("p",null,Object(o.b)("strong",null,"Last modified:")," 2021-10-11")))}d.isMDXComponent=!0}}]);